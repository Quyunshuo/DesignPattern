# 迭代器模式 - Iterator Pattern

## 概念

迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示

## 案例

* 对象村餐厅和对象村煎饼屋合并新招的女招待 - 《Head First 设计模式》   
  两个餐厅使用的不同的聚合数据结构，所以无法合并菜单，新招来了一个女招待负责合并后餐厅的服务，我们需要解决的就是如何让两个不同数据结构的菜单一起工作。

# 知识点

* 迭代器模式让我们能游走于聚合内的每一个元素，而又不暴露其内部的表示。把游走的任务放在了迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所。
* 迭代器模式依赖于一个名为迭代器的接口，一旦我们有了这个接口，就可以为各种对象集合实现迭代器：数组、列表、散列表...
* 当我们说"集合"（collection）的时候，我们指的是一群对象。其存储方式可以是各式各样的数据结构。例如：列表、数组、散列表，无论用什么方式存储，一律可以视为是集合，有的时候也被成为聚合（aggregate）。
* 对于散列表这样的集合，元素之间并没有明显的次序关系，我们该怎么办？
    * 迭代器意味着没有次序。只是取出所有的元素，并不表示取出元素的先后就代表元素的大小次序。对于迭代器来说，数据结构可以是有次序的，或是没有次序的，甚至数据可以是重复的。除非某个集合的文件有特别说明，否则不可以对迭代器所取出的元素大小顺序作出假设。

# 设计原则

* 单一职责  
  一个类应该只有一个引起变化的原因  
  类的每个责任都有改变的潜在区域。超过一个责任就意味着超过一个改变的区域。

* 内聚（cohesion）  
  内聚这个术语用来度量一个类或模块紧密地达到单一目的和责任。  
  当一个模块或一个类被设计成只支持一组相关的功能时，我们说它具有高内聚；反之，当被设计成支持一组不相关的功能时，我们说它具有低内聚。  
  内聚是一个比单一职责原则更普遍的概念，但两者其实关系是很密切的。遵守这个原则的类容易具有很高的凝聚力，而且比背负许多责任的低内聚类更容易维护。