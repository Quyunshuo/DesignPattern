# 外观模式 - Facade Pattern

## 概念

外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

## 案例

* 家庭影院 - 《Head First 设计模式》

## 知识点

* 外观模式允许我们让客户和子系统之间避免紧耦合
* 我们在设计中，不要让太多的类耦合在一起，免得修改系统中一部分，会影响到其它部分。如果许多类之间相互依赖，那么这个系统就会变成一个易碎的系统，它需要花很多成本维护，也许会因为太复杂而不易被其他人了解。
* 有了外观模式，通过实现一个提供更合理的接口的外观类，可以将一个复杂的子系统变得容易使用。如果你需要复杂子系统的强大威力，别担心，还是可以使用原来的复杂接口的；但如果你需要的是一个方便使用的接口，那就使用外观
* 外观没有"封装"子系统的类，外观只提供简化的接口。所以客户如果觉得有必要，依然可以直接使用子系统的类，这是外观模式一个很好的特征：提供简化接口的同时，依然将系统完整的功能暴露出来，以供需要的人使用
* 可以为一个子系统创建许多个外观。
* 适配器模式将一个或多个类接口变成客户所期望的一个接口。虽然大多数教科书所采用的例子中适配器只适配一个类，但是你可以适配很多类来提供一个接口让客户端编码。类似地，一个外观也可以只针对一个拥有复杂接口的类提供简化的接口。两种模式的差异，不在于它们包装了几个类，而是在于它们的意图。适配器模式的意图是："
改变"接口并符合客户的期望；而外观模式的意图是，提供子系统的一个简化接口
* 外观模式不止简化了接口，也将客户从组件的子系统中解耦
* 外观和适配器模式都可以包装许多类，但是外观模式的意图是简化接口，而适配器的意图是将接口转换成不同接口
* 当需要简化并统一一个很大的接口或者一群负责的接口时，使用外观
* 实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行
* 适配器将一个对象包装起来改变其接口；装饰者将一个对象包装起来以增加新的行为和责任；而外观将一群对象"包装"起来以简化其接口